# C++基础

## 程序设计基础

#### 内存分配与管理

##### 内存分配方式

  由C/C++编译的程序占用的内存分为以下几个部分

1. 栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
2. 堆区(heap)：一般由程序员分配释放（malloc/free、new/delete），若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局区(static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。
4. 文字常量区：常量字符串就是放在这里的，程序结束后由系统释放。
5. 程序代码区：存放函数体的二进制代码

##### 堆和栈区别

- 申请方式不同。
  - 栈由系统自动分配。
  - 堆由程序员手动分配。
- 申请大小限制不同。
  - 栈向低地址方向增长，栈顶和栈底是之前预设好的，大小固定。
  - 堆向高地址方向增长，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈，速度快，是一个先进后出的队列，进出一一对应，不会产生碎片。
  - 堆，速度慢，频繁的new/delete会造成大量碎片，使程序效率降低。

##### 内存管理

**malloc、calloc、realloc、alloca**

1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位(bit)都初始化为0
3. realloc：更改以前分配的内存长度(增加或减少)。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca不宜使用在必须广泛移植的程序中,。C99中支持变长数组(VLA), 可以用来替代alloca()。

**malloc、free**

申请内存，确认是否申请成功

```c++
char *str = (char*) malloc(100);
assert(str != nullptr);
```

释放内存后指针置空

```c++
free(p); 
p = nullptr;
```

**new、delete**

1. new/new[]：完成两件事，先底层调用malloc分了配内存，然后创建一个对象（调用构造函数）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用free释放空间。
3. new在申请内存时会自动计算所需字节数，而malloc则需我们自己输入申请内存空间的字节数。

```c++
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

##### 内存泄露

​	堆是动态分配内存的，并且可以分配很大的内存，使用不好会产生内存泄露。频繁使用malloc和free会产生内存碎片。

​	所谓内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。一般常说的内存泄漏是指堆内存的泄露。内存泄露其实并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏与许多其他问题有着相似的症状，并且通常情况下只能由哪些可以获得程序源码的程序员才可以分析出来。

​	应用程序一般使用malloc、calloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责响应地调用free、delete释放内存块，否则这块内存就不能再次使用，造成内存泄露。	

#### 引用和指针

- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

#### 指针数组和数组指针

​	指针数组，是指一个数组里面装着指针，也即指针数组是一个数组。一个有10个指针的数组，其中每个指针指向一个整型数，那么次数组定义位：

```c
int *a[10];
```

​	数组指针，是指一个指向数组的指针，它其实还是指针，只不过它指向整个数组。一个指向有10个元素整形数组的指针定义为：

```c
int （*a）[10];
```

#### 左值引用与右值引用

左值引用符：&

右值引用符：&&

左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。

由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。

左值、右值引用的几个例子：

 ```c++
int i = 42;//如前所述，i是一个左值对象  
int &r = i;//正确，左值引用绑定到左值对象i  
int &&rr = i;//错误，右值引用绑定左值对象  
int &r2 = i * 42;//错误，如前所述i*42是临时变量，是右值，而&r2是左值引用  
int &&rr2 = i * 42;//正确，右值引用绑定右值对象  
 ```

注意：以上绑定规则有一个例外，如果左值引用是const类型的，则其可以绑定到右值对象上。

```c++
const int &r3 = i * 42;//正确，我们可以将一个const的引用绑定到一个右值对象上  
```

对于一个左值，若想使用其右值引用，我们可以用move函数：

```c
int &&rr3 = std::move(rr1);//正确，显式使用rr1的右值引用  
```

#### strlen和sizeof

自定义函数实现strlen功能：

```c
int strlen(const char *str){
    assert(str!=NULL);
    int len=0;
    while((*str++)!='\0')
        len++;
    return len;
}
int strlen(const char *str){
    assert(str!=NULL);
    return *str=='\0'? 0 : (1+strlen(++str));
}
```

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**
- `strlen("\0")=0;sizeof("\0")=2;`

#### sizeof（结构体、联合体、类）

#### strcmp

```c
int Strcmy(const char* str1,const char* str2)
{
	assert(str1!=NULL&&str2!=NULL);
	int ret = 0;
	while (!(ret = *(unsigned char*)str1 - *(unsigned char*)str2) && *str1)
	{
		str1++;
		str2++;
	}
	if (ret < 0) return -1;
	else if (ret > 0) return 1;
	else return 0;
}
```

#### strcat,strcpy,strncpy

`strcat(dest,scr)`把src所指字符串添加到dest尾处（覆盖dest结尾的'\'）并添加'\0'

```c++
char * my_strcat(char *dest, const char *ptr)
{
	char *temp = dest;
	while (*temp != '\0')
	{
		temp++;
	}
	while (*ptr != '\0')
	{
		*temp = *ptr;
		temp++;
		ptr++;
	}
	*temp = '\0';
	return dest;
}
```

strcpy(dest,src)把从scr地址开始且还有null结束符的字符串复制到以dest开始的地址空间

```c++
char *my_strcpy( char *dst, const char *scr )  
{  
    char *ret = dst;//保存返回地址  
    assert(dst);  
    assert(scr);  
    while( *dst++ = *scr++ );//实现拷贝  
    return ret;  
}  
```

#### memcpy,memset

```c++
void *memcpy(void *dest,const void *src,size_t n);
```

功能：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。函数返回指向*dest的指针。

memcpy与strcpy区别

1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。strcpy只能用于字符串复制，并且它不仅复制字符串内容之外还会复制字符串的结束符。memcpy对于需要复制的内容没有限制，因此用途更广。
2. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符'\0'时才结束，所以容易溢出。memcpy则根据其第三个参数决定复制的长度。
3. 用途不同。通常在复制字符串时使用strcpy，而需要复制其他数据时一般用memcpy。

```c++
void *memset(void *s,int ch,sizet n);
```

功能：将s中前n个字节用ch替换并返回s，作用是一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法，

####[const关键字](https://www.cnblogs.com/chogen/p/4574118.html)

常量：

const限定符把一个对象转换成一个常量，因为常量定义后就不能修改，所以定义时必须初始化。

修饰类成员变量：

```c++
//用const修饰的类成员变量，只能在类的构造函数初始化列表中赋值，不能在类构造函数体内赋值。
class A
{
public：
    A(int x) : a(x)  // 正确
    {
         //a = x;    // 错误
    }
private：
    const int a;
};
```

修饰类成员函数：

```c++
//用const修饰的类成员函数，在该函数体内不能改变该类对象的任何成员变量, 也不能调用类中任何非const成员函数。
class A
{
public:
    int& getValue() const
    {
        // a = 10;    // 错误
        return a;
    }
private:
    int a;            // 非const成员变量
};
```

修饰类对象：

```c++
/*用const修饰的类对象，该对象内的任何成员变量都不能被修改。
因此不能调用该对象的任何非const成员函数，因为对非const成员函数的调用会有修改成员变量的企图。*/
class A
{
 public:
    void funcA() {}
    void funcB() const {}
};
int main
{
    const A a;
    a.funcB();    // 可以
    a.funcA();    // 错误

    const A* b = new A();
    b->funcB();    // 可以
    b->funcA();    // 错误
}
```

#### [static关键字](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

**c语言中static的用法：**

1、全局静态变量：

- 用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 static int temp；
- 内存中的位置：静态存储区，在整个程序运行期间一直存在。
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
- 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2、局部静态变量：

- 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
- 内存中的位置：静态存储区;
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；且<u>只在第一次被调用时定义</u>;
- 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3、静态函数：

　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

**c++中static的用法：**

1、类的静态成员：

```c++
class A{
	private:
	static int val;
};
int A::val=0；
```

　　在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其**属于该类的所有成员共有**，只有一个拷贝；

​	静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example中，语句int A::val=0;是定义静态数据成员；（类内声明，类外定义）

2、类的静态成员函数：

```c++
class A{
	private:
	static int func(int x);
};
```

　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，**不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用**、（非静态成员函数可以任意地访问静态成员函数和静态数据成员）；实际上，他就是增加了类的访问权限的全局函数；

　　void  A::func(int);

　　静态成员函数可以继承和覆盖，但**无法是虚函数**；

3、只在cpp内有效的全局变量：

　　在cpp文件的全局范围内声明：

　　static int val = 0；

　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

4、只在cpp内有效的全局函数：

　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

　　warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

#### volatile关键字

```c++
  volatile int i = 10; 
```

  - volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。
  - volatile关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
  - const 可以是 volatile （如只读的状态寄存器）
  - 指针可以是 volatile

#### struct和class

- C的struct与C++的class的区别：struct只是作为一种复杂数据类型定义，不能用于面向对象编程。 
- C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。

#### new/delete和malloc/free

 [new/delete实现]( http://blog.csdn.net/passion_wu128/article/details/38966581)

1. new/delete是c++关键字，需要编译器支持；malloc/free是库函数，需要头文件支持；

2. new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数。例如，`int* p1=new int[2],int * p2=malloc(2*sizeof(int))`;

3. new与delete直接返回具体类型的指针，而malloc与free返回void类型指针。

4. new是类型安全的，而malloc不是，例如，int * p=new float[2], 编译时就会报错；而`int * p=malloc(2*sizeof(int))`, 编译时编译器就无法指出错误来。

5.  new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

6. C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

#### define和const定义常量

- 用`#define MAX 255`定义的常量是**没有类型**的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

  用`const float MAX = 255;` 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多；

- 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

- 用define可以定义一些简单的函数，const是不可以定义函数的.

  - 具体来说，有以下几方面的区别：

    - 编译器处理方式 

      define – 在预处理阶段进行替换 
      const – 在编译时确定其值

    - 类型检查 

      define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
      const – 有数据类型，编译时会进行类型检查

    - 内存空间 

      define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
      const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

## C++相关语法

#### [auto和decltype](https://www.cnblogs.com/XiangfeiAi/p/4451904.html)

#### explicit

​	被修饰的构造函数类不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。类构造函数默认情况下声明为隐式的，即implicit。

####[四种强制类型转换](http://blog.csdn.net/u010275850/article/details/49452373)

C++的四种强制类型转换为：`static_cast、const_cast、reinterpret_cast和dynamic_cast`

类型转换的一般形式：`cast-name<type>(expression);`

**static_cast**

> 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast；
>
> 注：
>
> 顶层const：表示指针本身是个常量。如：int *const p；
>
> 底层const：表示指针所指的对象是一个常量。如：int const *p；
>

**const_cast**

> 该运算符只能改变运算对象的底层const。
>

**reinterpret_cast**

> 通常为运算对象的位模式提供较低层次上的重新解释。
>
> 注：
>
> 1、在指针之间转换，将一个类型的指针转换为另一个类型的指针，无关类型；
>
> 2、将指针值转换为一个整型数,但不能用于非指针类型的转换。
>

**dynamic_cast**

> 运行时类型识别（以区别以上三个均在编译时识别），用于将基类的指针或引用安全地转换成派生类的指针或引用。
>

**总 结**

- 去const属性用const_cast。
- 基本类型转换用static_cast。
- 多态类之间的类型转换用daynamic_cast。
- 不同类型的指针类型转换用reinterpreter_cast

#### 智能指针



#### hashmap、hashtable

​	总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小！

​    hash_map对空间的要求要比map高很多，所以是以空间换时间的方法，而且，hash_map如果hash函数和hash因子选择不好的话，也许不会达到你要的效果，所以至于用map，还是hash_map，从3个方面来权衡：查找速度, 数据量, 内存使用。

> java中hashmap与hashtable区别
>
> 1、HashMap是非线程安全的，HashTable是线程安全的。 
>
> 2、HashMap的键和值都允许有null值存在，而HashTable则不行。 
>
> 3、因为线程安全的问题，HashMap效率比HashTable的要高。 
>
> 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
>
> ​      一般现在**不建议用HashTable**,  ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在**多线程**环境下，现在也有同步的**ConcurrentHashMap**替代，没有必要因为是多线程而用HashTable。

#### extern “C”

- 被extern限定的函数或变量是extern类型的
- 被extern "C"修饰的变量和函数是按照C语言方式编译和连接的

extern "C" 的作用是让C++编译器将 `extern "C"` 声明的代码当作C语言代码处理，可以避免C++因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

```c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

#### **inline内联函数**

**特征：**

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch等复杂操作；
- 类中除了虚函数的其他函数都会自动隐式地当成内联函数。

**使用：**

```c++
// 声明1（加inline，建议使用）
inline int functionName(int first, int secend,...);
// 声明2（不加inline）
int functionName(int first, int secend,...);
// 定义
inline int functionName(int first, int secend,...) {/****/};
```

**编译器对inline函数的处理步骤：**

1. 将inline函数体复制到inline函数调用点处；
2. 为所用inline函数中的局部变量分配内存空间；
3. 将inline函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）。

**优点：**

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

**缺点**

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 虚函数&内联函数

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以delete时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

#### C++11新特性

##面向对象基础

####面向对象三大特性

- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。封装可以使得代码模块化。
- 继承性：让某种类型对象获得另一个类型对象的属性和方法。继承可以扩展已存在的代码
- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。多态的目的则是为了接口重用

####对多态的理解

​	多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

​	C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

​	多态可分为**静态多态**和**动态多态**。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早早绑定的，静态多态也往往被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于晚绑定，动态多态也往往被叫做动态联编。 
​	静态多态往往通过**函数重载**和**模版（泛型编程）**来实现

#### [拷贝构造函数中深拷贝和浅拷贝区别](https://www.cnblogs.com/always-chang/p/6107437.html)

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

#### 拷贝构造函数

#### 拷贝赋值操作符

#### 运算符重载

#### 构造函数析构函数调用顺序

#### 计算类的大小

## 虚函数相关

#### 虚函数

#### 纯虚函数

#### 析构函数为虚

```c++
#include <iostream.h>
class Base 
{ 
public: 
Base() { mPtr = new int; } 
~Base() { delete mPtr; cout<<"Base::Destruction"<<endl;} 
private: 
  int* mPtr; 
} ;

class Derived : public Base 
{ 
public: 
  Derived() { mDerived = new long; } 
  ~Derived() { delete mDerived; cout<<"Derived::Destruction"<<endl;} 
private: 
  long* mDerived; 
} ;

void main() 
{ 
  Base* p = new Derived; 
  delete p; 
}
```

输出结果只有：Base::Destruction

​	以上代码会产生内存泄露，因为new出来的是Derived类资源，采用一个基类的指针来接收，析构的时候，编译器因为只是知道这个指针是基类的，所以只将基类部分的内存析构了，而不会析构子类的，就造成了内存泄露，如果将基类的析构函数改成虚函数，就可以避免这种情况，因为虚函数是后绑定，其实就是在虚函数列表中，析构函数将基类的析构函数用实际对象的一组析构函数替换掉了，也就是先执行子类的虚函数再执行父类的虚函数，这样子类的内存析构了，父类的内存也释放了，就不会产生内存泄露。

注：

1.析构函数其实是一个函数，不论子类还是父类，虽然可能看起来名字不一样。而且析构函数执行过程都是执行子类再到父类。

2.多态的时候一定要将析构函数写成虚函数，防止内存泄露，各个子类维护自己内部数据释放。

## STL原理

#### 常用STL容器

- vector：底层数据结构为数组，支持快速随机访问
- list：底层数据结构为双向链表，支持快速增删
- deque：底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问
  - deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:
  - [堆1] --> [堆2] -->[堆3] --> ...
  - 每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.
- stack：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
- queue：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
  - （stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
- priority_queue：底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
- set：底层数据结构为红黑树，有序，不重复
- multiset：底层数据结构为红黑树，有序，可重复
- map：底层数据结构为红黑树，有序，不重复
- multimap：底层数据结构为红黑树，有序，可重复
- hash_set：底层数据结构为hash表，无序，不重复
- hash_multiset：底层数据结构为hash表，无序，可重复
- hash_map：底层数据结构为hash表，无序，不重复
- hash_multimap：底层数据结构为hash表，无序，可重复

#### [迭代器失效问题](https://www.cnblogs.com/qiaoconglovelife/p/5370396.html)

c++ primer（315）

​	向容器中添加和从容器中删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不在表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与未使用初始化指针一样的问题。

​	在向容器中添加元素后：

- 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、引用和指针都会失效。如果村春空间未重新分配，指向插入元素之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。

- 对于deque，插入到除尾位置外的任何位置都导致迭代器、引用和指针失效。如果在首尾添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

- 对于list和forward_list，指向容器的迭代器、指针和引用仍有效。

  当我们从容器中删除元素元素后，指向被删除元素的迭代器、指针和引用会失效，因为这些元素被销毁。当删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器、引用和指针失效。

- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。

- 对于vector和string，指向被删除之前元素的迭代器、引用或指针仍有效。

  注意：当我们删除元素时，尾后迭代器总会失效。

#### vector与list

​	1.vector数据结构
​		vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
​		因此能高效的进行随机存取，时间复杂度为o(1);
​		但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
​		另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

​	2.list数据结构
​		list是由双向链表实现的，因此内存空间是不连续的。
​		只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
​		但由于链表的特点，能高效地进行插入和删除。

区别：

1. vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。
2. list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等vector<int>::iterator和list<int>::iterator都重载了“++”运算符。
3. 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;
   如果需要大量的插入和删除，而不关心随机存取，则应使用list。

#### map与unordered_map

- map： map内部实现了一个**红黑树**，该结构具有自动排序的功能，因此map内部的所有元素都是**有序的**，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
- unordered_map: unordered_map内部实现了一个**哈希表**，因此其元素的排列顺序是杂乱的，**无序的**

#### map底层实现

红黑树特点：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子（外部节点）都是黑色。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从每个叶子到根的所有路径都包含相同数目的黑色节点

这些约束的好处是：保持了树的相对平衡，同时又比AVL的插入删除操作的复杂性要低许多。

为什么使用红黑树实现？

​	map,set底层都提供了排序功能，且查找速度快。红黑树实际上是AVL的一种变形，但是其比AVL(平衡二叉搜索树)具有更高的插入效率，当然查找效率会平衡二叉树稍微低一点点，毕竟平衡二叉树太完美了。但是这种查找效率的损失是非常值得的。它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log *n*)时间内做查找，插入和删除，这里的*n*是树中元素的数目。

#### vector实现

#### hash表实现 

## 其他

#### 遇到coredump要怎么调试