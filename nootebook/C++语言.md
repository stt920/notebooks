# C++基础

## 程序设计基础

#### 内存分配与管理

##### 内存分配方式

  由C/C++编译的程序占用的内存分为以下几个部分

1. 栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
2. 堆区(heap)：一般由程序员分配释放（malloc/free、new/delete），若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局区(static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。
4. 文字常量区：常量字符串就是放在这里的，程序结束后由系统释放。
5. 程序代码区：存放函数体的二进制代码

##### 堆和栈区别

- 申请方式不同。
  - 栈由系统自动分配。
  - 堆由程序员手动分配。
- 申请大小限制不同。
  - 栈向低地址方向增长，栈顶和栈底是之前预设好的，大小固定。
  - 堆向高地址方向增长，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈，速度快，是一个先进后出的队列，进出一一对应，不会产生碎片。
  - 堆，速度慢，频繁的new/delete会造成大量碎片，使程序效率降低。

##### 内存管理

**malloc、calloc、realloc、alloca**

1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位(bit)都初始化为0
3. realloc：更改以前分配的内存长度(增加或减少)。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca不宜使用在必须广泛移植的程序中,。C99中支持变长数组(VLA), 可以用来替代alloca()。

**malloc、free**

申请内存，确认是否申请成功

```c++
char *str = (char*) malloc(100);
assert(str != nullptr);
```

释放内存后指针置空

```c++
free(p); 
p = nullptr;
```

**new、delete**

1. new/new[]：完成两件事，先底层调用malloc分了配内存，然后创建一个对象（调用构造函数）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用free释放空间。
3. new在申请内存时会自动计算所需字节数，而malloc则需我们自己输入申请内存空间的字节数。

```c++
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

##### 内存泄露

​	堆是动态分配内存的，并且可以分配很大的内存，使用不好会产生内存泄露。频繁使用malloc和free会产生内存碎片。

​	所谓内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。一般常说的内存泄漏是指堆内存的泄露。内存泄露其实并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏与许多其他问题有着相似的症状，并且通常情况下只能由哪些可以获得程序源码的程序员才可以分析出来。

​	应用程序一般使用malloc、calloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责响应地调用free、delete释放内存块，否则这块内存就不能再次使用，造成内存泄露。	

##### new/delete和malloc/free区别

 [new/delete实现]( http://blog.csdn.net/passion_wu128/article/details/38966581)

1. new/delete是c++关键字，需要编译器支持；malloc/free是库函数，需要头文件支持；

2. new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数。例如，`int* p1=new int[2],int * p2=malloc(2*sizeof(int))`;

3. new与delete直接返回具体类型的指针，而malloc与free返回void类型指针。

4. new是类型安全的，而malloc不是，例如，int * p=new float[2], 编译时就会报错；而`int * p=malloc(2*sizeof(int))`, 编译时编译器就无法指出错误来。

5. new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

   malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

6. C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

#### 引用和指针

- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

#### 指针数组和数组指针

​	指针数组，是指一个数组里面装着指针，也即指针数组是一个数组。一个有10个指针的数组，其中每个指针指向一个整型数，那么次数组定义位：

```c
int *a[10];
```

​	数组指针，是指一个指向数组的指针，它其实还是指针，只不过它指向整个数组。一个指向有10个元素整形数组的指针定义为：

```c
int （*a）[10];
```

#### strlen和sizeof

自定义函数实现strlen功能：

```c
int strlen(const char *str){
    assert(str!=NULL);
    int len=0;
    while((*str++)!='\0')
        len++;
    return len;
}
int strlen(const char *str){
    assert(str!=NULL);
    return *str=='\0'? 0 : (1+strlen(++str));
}
```

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**
- `strlen("\0")=0;sizeof("\0")=2;`

#### sizeof（结构体、联合体、类）

#### 字符串相关函数

##### strcmp

```c
int Strcmy(const char* str1,const char* str2)
{
	assert(str1!=NULL&&str2!=NULL);
	int ret = 0;
	while (!(ret = *(unsigned char*)str1 - *(unsigned char*)str2) && *str1)
	{
		str1++;
		str2++;
	}
	if (ret < 0) return -1;
	else if (ret > 0) return 1;
	else return 0;
}
```

##### strcat,strcpy,strncpy

`strcat(dest,scr)`把src所指字符串添加到dest尾处（覆盖dest结尾的'\'）并添加'\0'

```c++
char * my_strcat(char *dest, const char *ptr)
{
	char *temp = dest;
	while (*temp != '\0')
	{
		temp++;
	}
	while (*ptr != '\0')
	{
		*temp = *ptr;
		temp++;
		ptr++;
	}
	*temp = '\0';
	return dest;
}
```

strcpy(dest,src)把从scr地址开始且还有null结束符的字符串复制到以dest开始的地址空间

```c++
char *my_strcpy( char *dst, const char *scr )  
{  
    char *ret = dst;//保存返回地址  
    assert(dst);  
    assert(scr);  
    while( *dst++ = *scr++ );//实现拷贝  
    return ret;  
}  
```

#### memcpy,memset

```c++
void *memcpy(void *dest,const void *src,size_t n);
```

功能：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。函数返回指向*dest的指针。

memcpy与strcpy区别

1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。strcpy只能用于字符串复制，并且它不仅复制字符串内容之外还会复制字符串的结束符。memcpy对于需要复制的内容没有限制，因此用途更广。
2. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符'\0'时才结束，所以容易溢出。memcpy则根据其第三个参数决定复制的长度。
3. 用途不同。通常在复制字符串时使用strcpy，而需要复制其他数据时一般用memcpy。

```c++
void *memset(void *s,int ch,sizet n);
```

功能：将s中前n个字节用ch替换并返回s，作用是一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法，

####[const关键字](https://www.cnblogs.com/chogen/p/4574118.html)

常量：

const限定符把一个对象转换成一个常量，因为常量定义后就不能修改，所以定义时必须初始化。

修饰类成员变量：

```c++
//用const修饰的类成员变量，只能在类的构造函数初始化列表中赋值，不能在类构造函数体内赋值。
class A
{
public：
    A(int x) : a(x)  // 正确
    {
         //a = x;    // 错误
    }
private：
    const int a;
};
```

修饰类成员函数：

```c++
//用const修饰的类成员函数，在该函数体内不能改变该类对象的任何成员变量, 也不能调用类中任何非const成员函数。
class A
{
public:
    int& getValue() const
    {
        // a = 10;    // 错误
        return a;
    }
private:
    int a;            // 非const成员变量
};
```

修饰类对象：

```c++
/*用const修饰的类对象，该对象内的任何成员变量都不能被修改。
因此不能调用该对象的任何非const成员函数，因为对非const成员函数的调用会有修改成员变量的企图。*/
class A
{
 public:
    void funcA() {}
    void funcB() const {}
};
int main
{
    const A a;
    a.funcB();    // 可以
    a.funcA();    // 错误

    const A* b = new A();
    b->funcB();    // 可以
    b->funcA();    // 错误
}
```

#### [static关键字](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

**c语言中static的用法：**

1、全局静态变量：

- 用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 static int temp；
- 内存中的位置：静态存储区，在整个程序运行期间一直存在。
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
- 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2、局部静态变量：

- 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
- 内存中的位置：静态存储区;
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；且<u>只在第一次被调用时定义</u>;
- 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3、静态函数：

　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

**c++中static的用法：**

1、类的静态成员：

```c++
class A{
	private:
	static int val;
};
int A::val=0；
```

　　在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其**属于该类的所有成员共有**，只有一个拷贝；

​	静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example中，语句int A::val=0;是定义静态数据成员；（类内声明，类外定义）

2、类的静态成员函数：

```c++
class A{
	private:
	static int func(int x);
};
```

　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，**不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用**、（非静态成员函数可以任意地访问静态成员函数和静态数据成员）；实际上，他就是增加了类的访问权限的全局函数；

　　void  A::func(int);

　　静态成员函数可以继承和覆盖，但**无法是虚函数**；

3、只在cpp内有效的全局变量：

　　在cpp文件的全局范围内声明：

　　static int val = 0；

　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

4、只在cpp内有效的全局函数：

　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

　　warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

#### volatile关键字

```c++
  volatile int i = 10; 
```

  - volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。
  - volatile关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
  - const 可以是 volatile （如只读的状态寄存器）
  - 指针可以是 volatile

#### define和const定义常量

- 用`#define MAX 255`定义的常量是**没有类型**的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

  用`const float MAX = 255;` 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多；

- 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

- 用define可以定义一些简单的函数，const是不可以定义函数的.

  - 具体来说，有以下几方面的区别：

    - 编译器处理方式 

      define – 在预处理阶段进行替换 
      const – 在编译时确定其值

    - 类型检查 

      define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
      const – 有数据类型，编译时会进行类型检查

    - 内存空间 

      define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
      const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

## C++相关语法

#### struct和class

- C的struct与C++的class的区别：struct只是作为一种复杂数据类型定义，不能用于面向对象编程。 
- C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。

#### 关键字

##### [auto和decltype](https://www.cnblogs.com/XiangfeiAi/p/4451904.html)

##### [explicit](https://www.cnblogs.com/ymy124/p/3632634.html)

​	explicit关键字只能用于**修饰只有一个参数的类构造函数**，它的作用是表明该构造函数是显示的，而非隐式的，跟它相对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下即声明为implicit。

作用：**禁止隐式调用类内的单参构造函数**，主要包括以下三层意思：

- 该关键字只能用来修饰类内部的构造函数；
- 禁止隐式调用拷贝构造函数；
- 禁止类对象之间的隐式转换；

```c++
class CTest1 {
public:
    CTest1(int n)
    {
        cout<<"Constructor of CTest1"<<endl;
    }
    CTest1(const CTest1&)
    {
        cout<<"Copy constructor of CTest1"<<endl;
    }
};
class CTest2 {
public:
    explicit CTest2(int n)
    {
        cout<<"Constructor of CTest2"<<endl;
    }
    explicit CTest2(const CTest2&)
    {
        cout<<"Copy constructor of CTest2"<<endl;
    }
};
int main()
{
    CTest1 a1(1);            //显示调用构造函数
    CTest1 b1 = 1;           //隐式调用构造函数
    CTest1 c1 = a1;          //隐式调用拷贝构造函数
    CTest1 d1(b1);           //显示调用拷贝构造函数
    CTest2 a2(2);            //显示调用构造函数
    CTest2 b2 = 2;           //隐式调用构造函数，编译错误
    CTest2 c2 = a2;          //隐式调用拷贝构造函数，编译错误
    CTest2 d2(b2);           //显示调用拷贝构造函数
    return 0;
}
```

####[显式类型转换](http://blog.csdn.net/u010275850/article/details/49452373)

c++primer（144）

C++的四种显式类型转换为：`static_cast、const_cast、reinterpret_cast和dynamic_cast`

类型转换的一般形式：`cast-name<type>(expression);`

**static_cast**

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast；

```c++
//强制类型转换以便执行浮点数除法
double slope=static_cast<double>(j)/i;
```

```c++
注：

顶层const：表示指针本身是个常量。如：int *const p；

底层const：表示指针所指的对象是一个常量。如：int const *p；
```

**const_cast**

该运算符只能改变运算对象的底层const。

```c++
const char *pc;
char *p=const_cast<char*>(pc);
```

**reinterpret_cast**

通常为运算对象的位模式提供较低层次上的重新解释。

```c++
int *ip;
char *pc=reinterpret_cast(ip);
```

注：

1、在指针之间转换，将一个类型的指针转换为另一个类型的指针，无关类型；

2、将指针值转换为一个整型数,但不能用于非指针类型的转换。

**dynamic_cast**

运行时类型识别（以区别以上三个均在编译时识别），用于将基类的指针或引用安全地转换成派生类的指针或引用。

**总 结**

- 去const属性用const_cast。
- 基本类型转换用static_cast。
- 多态类之间的类型转换用daynamic_cast。
- 不同类型的指针类型转换用reinterpreter_cast

#### [智能指针](https://www.cnblogs.com/lanxuezaipiao/p/4132096.html)

​	C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

##### shared_ptr

​	shared_ptr多个指针指向相同的对象。shared_ptr使用**引用计数**，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

- make_shared

  ​

#### hashmap、hashtable

​	总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小！

​    hash_map对空间的要求要比map高很多，所以是以空间换时间的方法，而且，hash_map如果hash函数和hash因子选择不好的话，也许不会达到你要的效果，所以至于用map，还是hash_map，从3个方面来权衡：查找速度, 数据量, 内存使用。

> java中hashmap与hashtable区别
>
> 1、HashMap是非线程安全的，HashTable是线程安全的。 
>
> 2、HashMap的键和值都允许有null值存在，而HashTable则不行。 
>
> 3、因为线程安全的问题，HashMap效率比HashTable的要高。 
>
> 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
>
> ​      一般现在**不建议用HashTable**,  ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在**多线程**环境下，现在也有同步的**ConcurrentHashMap**替代，没有必要因为是多线程而用HashTable。

#### extern “C”

- 被extern限定的函数或变量是extern类型的
- 被extern "C"修饰的变量和函数是按照C语言方式编译和连接的

extern "C" 的作用是让C++编译器将 `extern "C"` 声明的代码当作C语言代码处理，可以避免C++因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

```c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

#### **inline内联函数**

**特征：**

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch等复杂操作；
- 类中除了虚函数的其他函数都会自动隐式地当成内联函数。

**使用：**

```c++
// 声明1（加inline，建议使用）
inline int functionName(int first, int secend,...);
// 声明2（不加inline）
int functionName(int first, int secend,...);
// 定义
inline int functionName(int first, int secend,...) {/****/};
```

**编译器对inline函数的处理步骤：**

1. 将inline函数体复制到inline函数调用点处；
2. 为所用inline函数中的局部变量分配内存空间；
3. 将inline函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）。

**优点：**

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

**缺点**

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 虚函数&内联函数

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以delete时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

#### C++11新特性

##面向对象基础

####面向对象三大特性

- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。封装可以使得代码模块化。
- 继承性：让某种类型对象获得另一个类型对象的属性和方法。继承可以扩展已存在的代码
- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。多态的目的则是为了接口重用

####对多态的理解

​	多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

​	C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

​	多态可分为**静态多态**和**动态多态**。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早早绑定的，静态多态也往往被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于晚绑定，动态多态也往往被叫做动态联编。 
​	静态多态往往通过**函数重载**和**模版（泛型编程）**来实现

#### 构造/析构函数

##### [拷贝构造函数](https://www.cnblogs.com/alantu2018/p/8459250.html)

- **概念**

  ​	如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo{
public:
	Foo();			 //构造函数
	Foo(const Foo&);  //拷贝构造函数   
}
```

- **为什么参数为引用类型**

  ​	简单的回答是为了防止递归引用。
  ​	具体一些可以这么讲：当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导致又一次调用类A的拷贝构造函数，这就是一个无限递归。


- **调用时机**

1. 使用=定义变量的时候



2. 将一个队形作为形参传递给非引用类型的形参
3. 从一个返回为非引用雷系的函数返回一个对象
4. 用花括号初始化一个数组中的元素或一个聚合类中的成员

##### [深拷贝和浅拷贝](https://www.cnblogs.com/always-chang/p/6107437.html)

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

[例子](http://www.cnblogs.com/gossiplee/p/4612983.html)

```c
深拷贝：当对象中含有指针域的时候，在进行对象之间初始化（也就是调用拷贝构造函数）或者是=操作的时候（注：浅两者是不同的情况），将指针所包含的内存空间中的内容也进行拷贝

浅拷贝：当对象中含有指针域的时候，在进行对象之间初始化（也就是调用拷贝构造函数）或者是=操作的时候（注：浅两者是不同的情况），单纯将指针的值（也就是所指内存空间的首地址）拷贝，这就导致两个对象的指针域是同一块内存，所以在对象生存周期完毕时，调用析构函数，释放内存的时候出现core down的情况！

原因分析：因为C++提供的默认拷贝构造函数和=操作都是浅拷贝操作，即只是将指针域进行值复制。

解决方法：重写默认拷贝构造函数 和 重载=操作符
```

##### [拷贝赋值运算符](https://www.cnblogs.com/wangguchangqing/p/6141743.html)

- **概念**：

  - 与类控制其对象如何初始化一样，类也可以控制器对象如何赋值：

    ```c++
    Sales_data trans, accum;
    trans = accum;  //使用Sales_data的拷贝赋值运算符
    ```

    与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器也会为它合成一个。

  - 重载赋值运算符

    - 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

    - 如果是一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。

    - 拷贝赋值运算符接受一个与其类相同类型的参数：

      ```c++
      class Foo{
      public:
          Foo& operator=(const Foo&);  //赋值运算符
          //...
      };
      ```

      为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。注意，标准库通常要求保存在容器中的类型要有其赋值运算符，且其返回值是左侧运算对象的引用。

  - 合成拷贝赋值运算符

    ​	如果一个类未定义自己的拷贝赋值运算符，编译器会给它生成一个合成拷贝赋值运算符。

    ```c++
    //eg
    Sales_data&
    Sales_data::operator=(const Sales_data &rhs)
    {
        bookNo=rhs.bookNo;
        units_sold=rhs.units_sold;
        revenue=rhs.revenue;
        return *this;
    }
    ```

    ​


- **与拷贝构造函数区别：**

		拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个**已经存在的实例**。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。**调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符**。

##### 阻止拷贝

1. 定义删除的函数

   ​	在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除函数来阻止拷贝。删除函数：虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：

   ```c++
   struct NoCopy{
       NoCopy()=default;         //使用合成的默认构造函数
       NoCopy(const NoCopy&)=delete;                      //阻止拷贝
       NoCopy& operator=(const NoCopy&)=delete;           //阻止赋值
       ~NoCopy()=default;        //使用合成的析构函数
   }
   ```

   注：析构函数不能是删除的函数；

2. private拷贝控制

   ​	在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝：

   ```c++
   class PrivateCopy{
   private:
       PrivateCopy(const PrivateCopy&);
       PrivateCopy &operator=(const PrivateCopy&);
   public:
       PrivateCopy()=default;
       ~PrivateCopy();     //用户可以定义此类型的对象，但无法拷贝它们
   }
   ```

##### 析构函数

- 析构函是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：

  ```c++
  class Foo{
  public:
      ~Foo();   //析构函数
      //...
  };
  ```

  由于析构函数不接受参数，因此它**不能被重载**。对于一个给定类，只会由唯一一个析构函数。

- 在一个构造函数中，成员的初始化时在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。**成员按初始化顺序的逆序进行销毁**。

- 无论何时一个对象被销毁，就会自动调用其析构函数：

  ```c++
  1.变量在离开其作用域时被销毁
  2.当一个对象被销毁时，其成员被销毁
  3.容器(无论是标准容器还是数组)被销毁时，其元素被销毁
  4.对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
  5.对于临时对象，当创建它的完整表达式结束时被销毁
  ```

##### 左值引用&右值引用

左值引用符：&

右值引用符：&&

**左值&右值：**

- 左值：一般指的是一个对象，或者说是一个持久的值，例如赋值的返回值、下标操作、解引用以及前置递增等。
- 右值：一个短暂的值，比如一个表达式的求值结果、函数返回值以及一个字面值等。

**右值引用作用：**

​    为了支持移动操作（包括移动构造函数和移动赋值函数），C++才引入了一种新的引用类型——右值引用，可以自由接管右值引用的对象内容。

**区别：**

1. 绑定的对象（引用的对象）不同，左值引用绑定的是返回左值引用的函数、赋值、下标、解引用、前置递增递减
2. 左值持久，右值短暂，右值只能绑定到**临时对象**，所引用的对象将要销毁或该对象没有其他用户
3. 使用右值引用的代码可以自由的接管所引用对象的内容

**others：**

左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。

由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。

左值、右值引用的几个例子：

```c++
int i = 42;//如前所述，i是一个左值对象  
int &r = i;//正确，左值引用绑定到左值对象i  
int &&rr = i;//错误，右值引用绑定左值对象  
int &r2 = i * 42;//错误，如前所述i*42是临时变量，是右值，而&r2是左值引用  
int &&rr2 = i * 42;//正确，右值引用绑定右值对象  
```

注意：以上绑定规则有一个例外，如果左值引用是const类型的，则其可以绑定到右值对象上。

```c++
const int &r3 = i * 42;//正确，我们可以将一个const的引用绑定到一个右值对象上  
```

对于一个左值，若想使用其右值引用，我们可以用move函数：

```c
int &&rr3 = std::move(rr1);//正确，显式使用rr1的右值引用  
```

##### 对象移动

​	很多情况下都会发生对象拷贝，在某些情况下，对象拷贝后就立即被销毁，在这些情况下，移动而非拷贝对象会大幅提升性能。

​	**移动构造函数**第一个参数是该类类型的一个引用，不同于拷贝构造函数的是，这个引用是一个右值引用。与拷贝构造函数一样，任何额外参数都必须有默认实参。

​	下面实现一个StrVec到另一个StrVec的元素移动而非拷贝：

```c++
StrVec::StrVec(Strvec &&s) noexcept  //移动操作不应抛出任何异常
    //成员初始化器接管s中的资源
    ：elements(s.elements),first_free(s.first_free),cap(s.cap)
{
    //令s进入这样的状态——对其运行析构函数是安全的
    s.elements=s.first_free=s.cap=nullptr；//stt：使移动源对象指向null，避免之后内存两次释放
}
```

​	与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象继续存在。最终，移动源对象会被销毁，意味着将在其上运行析构函数。



#### 运算符重载

#### 友元函数

#### 计算类的大小

#### 虚函数相关

##### 虚函数

##### 虚函数表

##### 纯虚函数

##### 析构函数为虚

```c++
#include <iostream.h>
class Base 
{ 
public: 
Base() { mPtr = new int; } 
~Base() { delete mPtr; cout<<"Base::Destruction"<<endl;} 
private: 
  int* mPtr; 
} ;

class Derived : public Base 
{ 
public: 
  Derived() { mDerived = new long; } 
  ~Derived() { delete mDerived; cout<<"Derived::Destruction"<<endl;} 
private: 
  long* mDerived; 
} ;

void main() 
{ 
  Base* p = new Derived; //父类指针指向子类对象
  delete p; 
}
```

输出结果只有：Base::Destruction

​	以上代码会产生内存泄露，因为new出来的是Derived类资源，采用一个基类的指针来接收，析构的时候，编译器因为只是知道这个指针是基类的，所以只将基类部分的内存析构了，而不会析构子类的，就造成了内存泄露，如果将基类的析构函数改成虚函数，就可以避免这种情况，因为虚函数是后绑定，其实就是在虚函数列表中，析构函数将基类的析构函数用实际对象的一组析构函数替换掉了，也就是先执行子类的虚函数再执行父类的虚函数，这样子类的内存析构了，父类的内存也释放了，就不会产生内存泄露。

注：

1.析构函数其实是一个函数，不论子类还是父类，虽然可能看起来名字不一样。而且析构函数执行过程都是执行子类再到父类。

2.多态的时候一定要将析构函数写成虚函数，防止内存泄露，各个子类维护自己内部数据释放。

## STL原理

#### STL六大组件

1. 容器（containers）:各种数据结构，如vector,list,deque,set,map，用来存放数据。从实现角度来看STL容器是一种class template。
2. 算法（algorithms）:各种常用的算法如sort,search,copy,erase… 从实现角度来看STL算法是一种function template。
3. 迭代器（iterators）:扮演容器与算法之间的胶合剂，是所谓的”泛型指针“。共有物种类型，以及其他衍生变化。从实现角度来看，迭代器是一种将operator*, operator->, operator++, operator--等指针相关操作予以重载的class template。
4. 仿函数（functors）:行为类似函数，可座位算法的某种策略（policy）。从实现角度来看，仿函数是一种重载了operator()的class或class template。一般函数指针可视为侠义的放函数。
5. 配接器（adapters）:一种用来修饰容器或仿函数或迭代器接口的东西。例如STL提供的queue和stack虽然看似容器，其实只能算是一种容器适配器，因为他们的底层全部借助deque，所有的操作都由底层的deque供应。
6. 配置器（allocators）:负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。

#### [STL空间配置器](http://ju.outofmemory.cn/entry/80083)

##### WHY

1. 小块内存带来的内存碎片问题

   ​	单从分配的角度来看。由于频繁分配、释放小块内存容易在堆中造成外碎片(极端情况下就是堆中空闲的内存总量满足一个请求，但是这些空闲的块都不连续，导致任何一个单独的空闲的块都无法满足这个请求)。

2. 小块内存频繁申请释放带来的性能问题

   ​	开辟空间的时候，分配器会去找一块空闲块给用户，找空闲块也是需要时间的，尤其是在外碎片比较多的情况下。如果分配器其找不到，就要考虑处理假碎片现象(释放的小块空间没有合并)，这时候就要将这些已经释放的的空闲块进行合并，这也是需要时间的。

   ​	malloc在开辟空间的时候，这些空间会带有一些附加的信息，这样的话也就造成了空间的利用率有所降低，尤其是在频繁申请小块内存的时候。

   - 解决方法：

   		为了解决上面这些问题，所以就提出有了内存池的概念。内存池最基本的思想就是一次向heap申请一块很大的内存(内存池)，如果申请小块内存的话就直接到内存池中去要。这样的话，就能够有效的解决上面所提到的问题。

##### [两级空间配置器](https://www.cnblogs.com/dwdxdy/archive/2012/06/05/2537208.html)

​	SGI STL提供两级空间配置器，第一级空间配置器使用malloc/free函数，当分配的空间大小超过128 bytes的时候使用第一级空间配置器；第二级空间配置器使用了内存池技术，当分配的空间大小小于128 bytes的时候，将使用第二级空间配置器。

​	SGI STL的第二级内存配置器维护了一个free-list数组，分别用于管理8, 16, 24, 32,……，128 bytes的小额区块，free-list的节点结构如下：

```c++
union obj
{
    union obj* free_list_link;
    char client_data[1];
};
```

​	这里使用union结构，是为了节省空间，也就是说，当节点位于free-list时，通过free_list_link指向下一块内存，而当节点取出来分配给用户使用的时候，整个节点的内存空间对于用户而言都是可用的，这样在用户看来，就完全意识不到free_list_link的存在，可以使用整块的内存了。

​	在分配内存时，会将大小向上调整为8的倍数，因为free-list中的节点大小全是8的倍数。

- 二级空间适配器分配内存时，自由链表变化示意图：

  ![secondmolloc1](./pic/secondmolloc1.png)

  第二级配置器分配内存时，其具体步骤如下：

  1).判断内存块大小，是否大于128bytes，若大于，则调用第一级配置器．若小于，进行步骤2).

  2).从16个自由链表中，根据内存块大小选择合适的自由链表．

  3).判断自由链表是否为空，若为空，则重新真充自由链表，否则，进行步骤4).

  4).调整当前自由链表指向一块内存块，并返回当前的内存块．(类似于链表的删除操作)

- 二级空间适配器释放内存时，自由链表变化示意图：

  ![secondalloc2](./pic/secondalloc2.png)

  第二级配置器释放内存时，其具体步骤如下：

  1).判断内存块大小，是否大于128bytes，若大于，则调用第一级配置器．若小于，进行步骤2).

  2).从16个自由链表中，根据内存块大小选择合适的自由链表．

  3).调整当前自由链表回收当前的内存块．(类似于链表的插入操作)

#### 常用STL容器

- vector：底层数据结构为数组，支持快速随机访问
- list：底层数据结构为双向链表，支持快速增删
- deque：底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问
  - deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:
  - [堆1] --> [堆2] -->[堆3] --> ...
  - 每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.
- stack：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
- queue：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
  - （stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
- priority_queue：底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
- set：底层数据结构为红黑树，有序，不重复
- multiset：底层数据结构为红黑树，有序，可重复
- map：底层数据结构为红黑树，有序，不重复
- multimap：底层数据结构为红黑树，有序，可重复
- hash_set：底层数据结构为hash表，无序，不重复
- hash_multiset：底层数据结构为hash表，无序，可重复
- hash_map：底层数据结构为hash表，无序，不重复
- hash_multimap：底层数据结构为hash表，无序，可重复

#### vector实现

​	vector采用的数据结构非常简单：**线性连续空间**。它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。

```c++
template <class T,class Alloc=alloc>
class vector{
	...
	protect:
	  iterator start;           //表示目前使用空间的头
	  iterator finish;          //表示目前使用空间的尾
	  iterator end_of_storage;  //表示目前可用空间的尾
	...
}
```

​	为了降低空间配置时的速度成本，vector实际配置的大小可能比用户需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的观念。一个vector的容量永远等于或大于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所（重新分配内容）。

![vector](./pic/vector.png)

​	注意，所谓动态增加大小，并不是在原来空间之后接续新空间（因为无法保证原空间之后尚有可供分配的空间），而是以原来大小两倍（vs为1.5，gcc为2）另外配置一块较大空间，然后将原来内容拷贝进来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就失效了。

**[为什么1.5倍或者2倍扩容？](https://blog.csdn.net/dengheCSDN/article/details/78985684)**

#### [迭代器失效问题](https://www.cnblogs.com/qiaoconglovelife/p/5370396.html)

c++ primer（315）

​	向容器中添加和从容器中删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不在表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与未使用初始化指针一样的问题。

在向容器中添加元素后：

- 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、引用和指针都会失效。如果存储空间未重新分配，指向插入元素之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。

- 对于deque，插入到除尾位置外的任何位置都导致迭代器、引用和指针失效。如果在首尾添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

- 对于list和forward_list，指向容器的迭代器、指针和引用仍有效。

当我们从容器中删除元素元素后，指向被删除元素的迭代器、指针和引用会失效，因为这些元素被销毁。当删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器、引用和指针失效。

- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。

- 对于vector和string，指向被删除之前元素的迭代器、引用或指针仍有效。

  注意：当我们删除元素时，尾后迭代器总会失效。

#### vector与list

1.vector数据结构
​	vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
​	因此能高效的进行随机存取，时间复杂度为o(1);
​	但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
​	另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

2.list数据结构
​	list是由双向链表实现的，因此内存空间是不连续的。
​	只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
​	但由于链表的特点，能高效地进行插入和删除。

区别：

1. vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。
2. list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等vector<int>::iterator和list<int>::iterator都重载了“++”运算符。
3. 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;
   如果需要大量的插入和删除，而不关心随机存取，则应使用list。

#### map与unordered_map

- map： map内部实现了一个**红黑树**，该结构具有自动排序的功能，因此map内部的所有元素都是**有序的**，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
- unordered_map: unordered_map内部实现了一个**哈希表**，因此其元素的排列顺序是杂乱的，**无序的**

#### map底层实现

红黑树特点：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子（外部节点）都是黑色。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从每个叶子到根的所有路径都包含相同数目的黑色节点

这些约束的好处是：保持了树的相对平衡，同时又比AVL的插入删除操作的复杂性要低许多。

为什么使用红黑树实现？

​	map,set底层都提供了排序功能，且查找速度快。红黑树实际上是AVL的一种变形，但是其比AVL(平衡二叉搜索树)具有更高的插入效率，当然查找效率会平衡二叉树稍微低一点点，毕竟平衡二叉树太完美了。但是这种查找效率的损失是非常值得的。它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log *n*)时间内做查找，插入和删除，这里的*n*是树中元素的数目。

#### hash表实现 

## 其他

#### 遇到coredump要怎么调试