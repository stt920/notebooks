<!-- GFM-TOC -->
* [C++基础](# C++基础)
* [c++语法](## c++语法)
* [程序的内存分配](##### 程序的内存分配)
* <!-- GFM-TOC -->


# C++基础

## c++语法

##### 程序的内存分配

  由C/C++编译的程序占用的内存分为以下几个部分

1. 栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
2. 堆区(heap)：一般由程序员分配释放（malloc/free、new/delete），若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局区(static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。
4. 文字常量区：常量字符串就是放在这里的，程序结束后由系统释放。
5. 程序代码区：存放函数体的二进制代码

##### 堆和栈区别

- 申请方式不同。
  - 栈由系统自动分配。
  - 堆由程序员手动分配。
- 申请大小限制不同。
  - 栈向低地址方向增长，栈顶和栈底是之前预设好的，大小固定。
  - 堆向高地址方向增长，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈，速度快，是一个先进后出的队列，进出一一对应，不会产生碎片。
  - 堆，速度慢，频繁的new/delete会造成大量碎片，使程序效率降低。

##### 引用和指针

- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

##### 指针数组和数组指针

​	指针数组，是指一个数组里面装着指针，也即指针数组是一个数组。一个有10个指针的数组，其中每个指针指向一个整型数，那么次数组定义位：

```c
int *a[10];
```

​	数组指针，是指一个指向数组的指针，它其实还是指针，只不过它指向整个数组。一个指向有10个元素整形数组的指针定义为：

```c
int （*a）[10];
```

##### 左值引用与右值引用

左值引用符：&

右值引用符：&&

左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。

由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。

左值、右值引用的几个例子：

 ```c++
int i = 42;//如前所述，i是一个左值对象  
int &r = i;//正确，左值引用绑定到左值对象i  
int &&rr = i;//错误，右值引用绑定左值对象  
int &r2 = i * 42;//错误，如前所述i*42是临时变量，是右值，而&r2是左值引用  
int &&rr2 = i * 42;//正确，右值引用绑定右值对象  
 ```

注意：以上绑定规则有一个例外，如果左值引用是const类型的，则其可以绑定到右值对象上。

```c++
const int &r3 = i * 42;//正确，我们可以将一个const的引用绑定到一个右值对象上  
```

对于一个左值，若想使用其右值引用，我们可以用move函数：

```c
int &&rr3 = std::move(rr1);//正确，显式使用rr1的右值引用  
```

##### strlen和sizeof

自定义函数实现strlen功能：

```c
int strlen(const char *str){
    assert(str!=NULL);
    int len=0;
    while((*str++)!='\0')
        len++;
    return len;
}
int strlen(const char *str){
    assert(str!=NULL);
    return *str=='\0'? 0 : (1+strlen(++str));
}
```

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**
- `strlen("\0")=0;sizeof("\0")=2;`

##### strcmp

```c
int Strcmy(const char* str1,const char* str2)
{
	assert(str1!=NULL&&str2!=NULL);
	int ret = 0;
	while (!(ret = *(unsigned char*)str1 - *(unsigned char*)str2) && *str1)
	{
		str1++;
		str2++;
	}
	if (ret < 0) return -1;
	else if (ret > 0) return 1;
	else return 0;
}
```

##### strcat,strcpy,strncpy

`strcat(dest,scr)`把src所指字符串添加到dest尾处（覆盖dest结尾的'\'）并添加'\0'

```c++
char * my_strcat(char *dest, const char *ptr)
{
	char *temp = dest;
	while (*temp != '\0')
	{
		temp++;
	}
	while (*ptr != '\0')
	{
		*temp = *ptr;
		temp++;
		ptr++;
	}
	*temp = '\0';
	return dest;
}
```

strcpy(dest,src)把从scr地址开始且还有null结束符的字符串复制到以dest开始的地址空间

```c++
char *my_strcpy( char *dst, const char *scr )  
{  
    char *ret = dst;//保存返回地址  
    assert(dst);  
    assert(scr);  
    while( *dst++ = *scr++ );//实现拷贝  
    return ret;  
}  
```

##### memcpy,memset

```c++
void *memcpy(void *dest,const void *src,size_t n);
```

功能：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。函数返回指向*dest的指针。

memcpy与strcpy区别

1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。strcpy只能用于字符串复制，并且它不仅复制字符串内容之外还会复制字符串的结束符。memcpy对于需要复制的内容没有限制，因此用途更广。
2. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符'\0'时才结束，所以容易溢出。memcpy则根据其第三个参数决定复制的长度。
3. 用途不同。通常在复制字符串时使用strcpy，而需要复制其他数据时一般用memcpy。

```c++
void *memset(void *s,int ch,sizet n);
```

功能：将s中前n个字节用ch替换并返回s，作用是一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法，

#####[const关键字](https://www.cnblogs.com/chogen/p/4574118.html)

常量：

const限定符把一个对象转换成一个常量，因为常量定义后就不能修改，所以定义时必须初始化。

修饰类成员变量：

```c++
//用const修饰的类成员变量，只能在类的构造函数初始化列表中赋值，不能在类构造函数体内赋值。
class A
{
public：
    A(int x) : a(x)  // 正确
    {
         //a = x;    // 错误
    }
private：
    const int a;
};
```

修饰类成员函数：

```c++
//用const修饰的类成员函数，在该函数体内不能改变该类对象的任何成员变量, 也不能调用类中任何非const成员函数。
class A
{
public:
    int& getValue() const
    {
        // a = 10;    // 错误
        return a;
    }
private:
    int a;            // 非const成员变量
};
```

修饰类对象：

```c++
/*用const修饰的类对象，该对象内的任何成员变量都不能被修改。
因此不能调用该对象的任何非const成员函数，因为对非const成员函数的调用会有修改成员变量的企图。*/
class A
{
 public:
    void funcA() {}
    void funcB() const {}
};
int main
{
    const A a;
    a.funcB();    // 可以
    a.funcA();    // 错误

    const A* b = new A();
    b->funcB();    // 可以
    b->funcA();    // 错误
}
```

##### [static关键字](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

**c语言中static的用法：**

1、全局静态变量：

- 用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 static int temp；
- 内存中的位置：静态存储区，在整个程序运行期间一直存在。
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
- 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2、局部静态变量：

- 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
- 内存中的位置：静态存储区;
- 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；且<u>只在第一次被调用时定义</u>;
- 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3、静态函数：

　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

**c++中static的用法：**

1、类的静态成员：

```c++
class A{
	private:
	static int val;
};
int A::val=0；
```

　　在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其**属于该类的所有成员共有**，只有一个拷贝；

​	静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example中，语句int A::val=0;是定义静态数据成员；（类内声明，类外定义）

2、类的静态成员函数：

```c++
class A{
	private:
	static int func(int x);
};
```

　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，**不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用**、（非静态成员函数可以任意地访问静态成员函数和静态数据成员）；实际上，他就是增加了类的访问权限的全局函数；

　　void  A::func(int);

　　静态成员函数可以继承和覆盖，但**无法是虚函数**；

3、只在cpp内有效的全局变量：

　　在cpp文件的全局范围内声明：

　　static int val = 0；

　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

4、只在cpp内有效的全局函数：

　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

　　warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

##### volatile关键字

- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

#####[auto和decltype](https://www.cnblogs.com/XiangfeiAi/p/4451904.html)

##### struct和class

- C的struct与C++的class的区别：struct只是作为一种复杂数据类型定义，不能用于面向对象编程。 
- C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。

##### new/delete和malloc/free

 [new/delete实现]( http://blog.csdn.net/passion_wu128/article/details/38966581)

1. new/delete是c++关键字，需要编译器支持；malloc/free是库函数，需要头文件支持；

2. new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数。例如，`int* p1=new int[2],int * p2=malloc(2*sizeof(int))`;

3. new与delete直接返回具体类型的指针，而malloc与free返回void类型指针。

4. new是类型安全的，而malloc不是，例如，int * p=new float[2], 编译时就会报错；而`int * p=malloc(2*sizeof(int))`, 编译时编译器就无法指出错误来。

5.  new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

6. C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

##### define和const定义常量

- 用`#define MAX 255`定义的常量是**没有类型**的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

  用`const float MAX = 255;` 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多；

- 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

- 用define可以定义一些简单的函数，const是不可以定义函数的.

  - 具体来说，有以下几方面的区别：

    - 编译器处理方式 

      define – 在预处理阶段进行替换 
      const – 在编译时确定其值

    - 类型检查 

      define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
      const – 有数据类型，编译时会进行类型检查

    - 内存空间 

      define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
      const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

##### explicit

​	被修饰的构造函数类不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。类构造函数默认情况下声明为隐式的，即implicit。

#####[四种强制类型转换](http://blog.csdn.net/u010275850/article/details/49452373)

C++的四种强制类型转换为：`static_cast、const_cast、reinterpret_cast和dynamic_cast`

类型转换的一般形式：`cast-name<type>(expression);`

**static_cast**

> 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast；
>
> 注：
>
> 顶层const：表示指针本身是个常量。如：int *const p；
>
> 底层const：表示指针所指的对象是一个常量。如：int const *p；
>

**const_cast**

> 该运算符只能改变运算对象的底层const。
>

**reinterpret_cast**

> 通常为运算对象的位模式提供较低层次上的重新解释。
>
> 注：
>
> 1、在指针之间转换，将一个类型的指针转换为另一个类型的指针，无关类型；
>
> 2、将指针值转换为一个整型数,但不能用于非指针类型的转换。
>

**dynamic_cast**

> 运行时类型识别（以区别以上三个均在编译时识别），用于将基类的指针或引用安全地转换成派生类的指针或引用。
>

> 总 结
>
> 　　去const属性用const_cast。
>
> 　　基本类型转换用static_cast。
>
> 　　多态类之间的类型转换用daynamic_cast。
>
> 　　不同类型的指针类型转换用reinterpreter_cast

##### 内存泄露

​	堆是动态分配内存的，并且可以分配很大的内存，使用不好会产生内存泄露。频繁使用malloc和free会产生内存碎片。

​	所谓内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。一般常说的内存泄漏是指堆内存的泄露。内存泄露其实并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏与许多其他问题有着相似的症状，并且通常情况下只能由哪些可以获得程序源码的程序员才可以分析出来。

​	应用程序一般使用malloc、calloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责响应地调用free、delete释放内存块，否则这块内存就不能再次使用，造成内存泄露。	

##### 智能指针

1. shared_ptr, unique_ptr, weak_ptr的区别？auto_ptr与shared_ptr的区别？weak_ptr主要是为了解决什么问题的？shared_ptr的内部实现？

##### hashmap、hashtable

​	总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小！

​    hash_map对空间的要求要比map高很多，所以是以空间换时间的方法，而且，hash_map如果hash函数和hash因子选择不好的话，也许不会达到你要的效果，所以至于用map，还是hash_map，从3个方面来权衡：查找速度, 数据量, 内存使用。

> java中hashmap与hashtable区别
>
> 1、HashMap是非线程安全的，HashTable是线程安全的。 
>
> 2、HashMap的键和值都允许有null值存在，而HashTable则不行。 
>
> 3、因为线程安全的问题，HashMap效率比HashTable的要高。 
>
> 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
>
> ​      一般现在**不建议用HashTable**,  ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在**多线程**环境下，现在也有同步的**ConcurrentHashMap**替代，没有必要因为是多线程而用HashTable。

##### C++11新特性

##面向对象基础

#####面向对象三大特性

- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。封装可以使得代码模块化。
- 继承性：让某种类型对象获得另一个类型对象的属性和方法。继承可以扩展已存在的代码
- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。多态的目的则是为了接口重用

#####对多态的理解

​	多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

​	C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

​	多态可分为**静态多态**和**动态多态**。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早早绑定的，静态多态也往往被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于晚绑定，动态多态也往往被叫做动态联编。 
​	静态多态往往通过**函数重载**和**模版（泛型编程）**来实现

##### [拷贝构造函数中深拷贝和浅拷贝区别](https://www.cnblogs.com/always-chang/p/6107437.html)

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

##### 拷贝构造函数相关

##### 构造函数析构函数调用顺序

##### 计算类的大小

## 虚函数相关

##### 虚函数

##### 纯虚函数

##### 析构函数为虚

```c++
#include <iostream.h>
class Base 
{ 
public: 
Base() { mPtr = new int; } 
~Base() { delete mPtr; cout<<"Base::Destruction"<<endl;} 
private: 
  int* mPtr; 
} ;

class Derived : public Base 
{ 
public: 
  Derived() { mDerived = new long; } 
  ~Derived() { delete mDerived; cout<<"Derived::Destruction"<<endl;} 
private: 
  long* mDerived; 
} ;

void main() 
{ 
  Base* p = new Derived; 
  delete p; 
}
```

输出结果只有：Base::Destruction

​	以上代码会产生内存泄露，因为new出来的是Derived类资源，采用一个基类的指针来接收，析构的时候，编译器因为只是知道这个指针是基类的，所以只将基类部分的内存析构了，而不会析构子类的，就造成了内存泄露，如果将基类的析构函数改成虚函数，就可以避免这种情况，因为虚函数是后绑定，其实就是在虚函数列表中，析构函数将基类的析构函数用实际对象的一组析构函数替换掉了，也就是先执行子类的虚函数再执行父类的虚函数，这样子类的内存析构了，父类的内存也释放了，就不会产生内存泄露。

注：

1.析构函数其实是一个函数，不论子类还是父类，虽然可能看起来名字不一样。而且析构函数执行过程都是执行子类再到父类。

2.多态的时候一定要将析构函数写成虚函数，防止内存泄露，各个子类维护自己内部数据释放。

## STL相关

##### [迭代器失效问题](https://www.cnblogs.com/qiaoconglovelife/p/5370396.html)

c++ primer（315）

​	向容器中添加和从容器中删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不在表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与未使用初始化指针一样的问题。

​	在向容器中添加元素后：

- 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、引用和指针都会失效。如果村春空间未重新分配，指向插入元素之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。

- 对于deque，插入到除尾位置外的任何位置都导致迭代器、引用和指针失效。如果在首尾添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

- 对于list和forward_list，指向容器的迭代器、指针和引用仍有效。

  当我们从容器中删除元素元素后，指向被删除元素的迭代器、指针和引用会失效，因为这些元素被销毁。当删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器、引用和指针失效。

- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。

- 对于vector和string，指向被删除之前元素的迭代器、引用或指针仍有效。

  注意：当我们删除元素时，尾后迭代器总会失效。

##### vector与list

​	1.vector数据结构
​		vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
​		因此能高效的进行随机存取，时间复杂度为o(1);
​		但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
​		另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

​	2.list数据结构
​		list是由双向链表实现的，因此内存空间是不连续的。
​		只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
​		但由于链表的特点，能高效地进行插入和删除。

区别：

1. vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。
2. list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等vector<int>::iterator和list<int>::iterator都重载了“++”运算符。
3. 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;
   如果需要大量的插入和删除，而不关心随机存取，则应使用list。

##### map与unordered_map

- map： map内部实现了一个**红黑树**，该结构具有自动排序的功能，因此map内部的所有元素都是**有序的**，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
- unordered_map: unordered_map内部实现了一个**哈希表**，因此其元素的排列顺序是杂乱的，**无序的**

##### map底层实现

红黑树特点：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子（外部节点）都是黑色。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从每个叶子到根的所有路径都包含相同数目的黑色节点

这些约束的好处是：保持了树的相对平衡，同时又比AVL的插入删除操作的复杂性要低许多。

为什么使用红黑树实现？

​	map,set底层都提供了排序功能，且查找速度快。红黑树实际上是AVL的一种变形，但是其比AVL(平衡二叉搜索树)具有更高的插入效率，当然查找效率会平衡二叉树稍微低一点点，毕竟平衡二叉树太完美了。但是这种查找效率的损失是非常值得的。它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log *n*)时间内做查找，插入和删除，这里的*n*是树中元素的数目。

##### vector实现

##### hash表实现 

## 其他

##### 遇到coredump要怎么调试