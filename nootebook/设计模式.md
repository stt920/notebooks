---
typora-root-url: pic
---

##设计模式

### 工厂模式

#### 简单工厂模式

​	所谓简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。

​	简单工厂模式的核心是，对于一个父类的多个继承子类，工厂对象的工厂函数根据用户输入，自动new出一个子类对象并返回其父类的指针，这样利用父类的指针执行父类的虚函数，就可以动态绑定子类的重写函数，从而实现多态。

​	对于一个只拥有加减乘除运算的简单计算器，我们设计一个Operation的父类，并构造加减乘除四个类继承父类重写运算函数GetResult。然后定义工厂类中的工厂函数，其根据用户的输入new出相应的对象实例并返回其父类的指针。

![270028459562457](/270028459562457.png)

```c++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<cstdio>
#include<stack>
#include<queue>
#include<limits>
using namespace std;
class Operation 
{
private:
	double _numberA = 0;
	double _numberB = 0;
public:
	double getA()
	{
		return  _numberA; 
	}
	double getB()
	{
		return  _numberB;
	}

	void setA(double x)
	{
		_numberA = x;
	}
	void setB(double x)
	{
		_numberB = x;
	}
	virtual double Getresult()
	{
		double result = 0;
		return result;
	}

};
class Add :public Operation {
	double Getresult()
	{
		double result = 0;
		result = getA() + getB();
		return result;
	}
};
class Sub :public Operation {
	double Getresult()
	{
		double result = 0;
		result = getA() - getB();
		return result;
	}
};
 class OperationFactory
 {
public:
	 static Operation* createoperate(char operate)
	{
		Operation* oper=NULL;
		switch (operate)
		{
		case '+': oper = new Add(); break;
		case '-': oper = new Sub(); break;
		}
		return oper;
	}
};
int main()
{
	double A, B;
	cin >> A >> B;
	Operation *oper;
	oper = OperationFactory::createoperate('+');
	oper->setA(A);
	oper->setB(B);
	cout << oper->Getresult()<< endl;
	return 0;
}
```

#### 工厂方法模式

![F0~7U~4_E9GRQXIODYKGW4D](/F0~7U~4_E9GRQXIODYKGW4D.png)

```c++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<cstdio>
#include<stack>
#include<queue>
#include<limits>
using namespace std;
class Operation
{
private:
	double _numberA = 0;
	double _numberB = 0;
public:
	double getA()
	{
		return  _numberA;
	}
	double getB()
	{
		return  _numberB;
	}

	void setA(double x)
	{
		_numberA = x;
	}
	void setB(double x)
	{
		_numberB = x;
	}
	virtual double Getresult()
	{
		double result = 0;
		return result;
	}

};
class Add :public Operation {
	double Getresult()
	{
		double result = 0;
		result = getA() + getB();
		return result;
	}
};
class Sub :public Operation {
	double Getresult()
	{
		double result = 0;
		result = getA() - getB();
		return result;
	}
};
/*----------------工厂方法模式-------------------------*/
__interface IFactory
{
	Operation* CreateOperation();
};


class  AddFactory :public IFactory
{
public:
	Operation* CreateOperation()
	{
		Operation* oper = NULL;
		oper = new Add();
		return oper;
	}
};
class  SubFactory :public IFactory
{
public:
	Operation* CreateOperation()
	{
		Operation* oper = NULL;
		oper = new Sub();
		return oper;
	}
};
/*----------------工厂方法模式-------------------------*/
int main()
{
	double A, B;
	cin >> A >> B;
	IFactory* operFactory=new SubFactory;
	Operation *oper = operFactory->CreateOperation();
	oper->setA(A);
	oper->setB(B);
	cout << oper->Getresult() << endl;
	return 0;
}
```



#### 抽象工厂模式

### [单例模式](https://www.cnblogs.com/qiaoconglovelife/p/5851163.html)

概念：单例模式是一种常的软件设计模式。它的核心结构只包含一个被称为单例的特殊类。它的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

应用场景：有一些对象只需要一个，如：对话框、系统日志、显卡等设备的驱动程序对象、一台PC连接一个键盘。
单例模式有3种实现方式：懒汉式、饿汉式和双重锁的形式。

**懒汉：第一次用到类的实例的时候才回去实例化。**

**饿汉：单例类定义的时候就进行实例化。**

![TIM图片20180412154002](/TIM图片20180412154002.png)

#### 1. 懒汉式

构造函数声明为private或者protect防止被外部函数实例化，内部保存一个private static的类指针保存唯一的实例，实例的动作有一个public的类方法实现。
代码如下：

```c++
class singleton   //实现单例模式的类  
{  
private:  
    singleton(){}  //私有的构造函数  
    static singleton* Instance;  
public:  
    static singleton* GetInstance()  
    {  
        if (Instance == NULL) //判断是否第一调用  
            Instance = new singleton();  
        return Instance;  
    }  
}; 
```

缺点：这个实现在单线程下是正确的，但在多线程情况下，如果两个线程同时首次调用GetInstance方法且同时检测到Instance是NULL，则两个线程会同时构造一个实例给Instance，这样就会发生错误。

#### 2. 改进的懒汉式（双重检查锁）

　思路：只有在第一次创建的时候进行加锁，当Instance不为空的时候就不需要进行加锁的操作。代码如下：　　　

```c++
class singleton   //实现单例模式的类  
{  
private:  
    singleton(){}  //私有的构造函数  
    static singleton* Instance;  
      
public:  
    static singleton* GetInstance()  
    {  
        if (Instance == NULL) //判断是否第一调用  
        {   
            Lock(); //表示上锁的函数  
            if (Instance == NULL)  
            {  
                Instance = new singleton();  
            }  
            UnLock() //解锁函数  
        }             
        return Instance;  
    }  
};  
```

#### 3. 饿汉式

饿汉式的特点是一开始就加载了，如果说懒汉式是“时间换空间”，那么饿汉式就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。饿汉模式是线程安全的。

```c++
class singleton   //实现单例模式的类  
{  
private:  
    singleton() {}  //私有的构造函数  
      
public:  
    static singleton* GetInstance()  
    {  
        static singleton Instance;  
        return &Instance;  
    }  
}; 
```

### 观察者模式

### 适配器模式

### 装饰模式

### 生产者消费者模式